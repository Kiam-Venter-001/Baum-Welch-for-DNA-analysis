string1 = 
  "GTTTATGTAGCTTACCCCCTCAAAGCAATACACTGAAAATGTTTCGACGGGTTTACATCA
CCCCATAAACAAACAGGTTTGGTCCTAGCCTTTCTATTAGCTCTTAGTAAGATTACACAT
GCAAGCATCCCCGCCCCGGTGAGTCACCCTCTAAATCGCCATGATCAAAAGGAACAAGTA
TCAAGCACGCAGCAATGCAGCTCAAAACGCTTAGCCTAGCCACACCCCCACGGGAGACAG
CAGTGATAAACCTTTAGCAATAAACGAAAGTTTAACTAAGCCATACTAACCCTAGGGTTG
GTCAATTTCGTGCCAGCTACCGCGGTCATACGATTAACCCAAGTCAATAGAAACCGGCGT
AAAGAGTGTTTTAGATCACCCCCCCCCCATAAAGCTAAAATTCACCTGAGTTGTAAAAAA
CTCCAGCTGATACAAAATAAACTACGAAAGTGGCTTTAACACATCTGAATACACAATAGC
TAAGACCCAAACTGGGATTAGATACCCCACTATGCTTAGCCCTAAACTTCAACAGTTAAA
TTAACAAAACTGCTCGCCAGAACACTACGAGCCACAGCTTAAAACTCAAAGGACCTGGCG
GTGCTTCATATCCCTCTAGAGGAGCCTGTTCTGTAATCGATAAACCCCGATCAACCTCAC
CGCCTCTTGCTCAGCCTATATACCGCCATCTTCAGCAAACCCTGATGAAGGTTACAAAGT
AAGCACAAGTACCCACGTAAGGACGTTAGGTCAAGGTGTAGCCTATGAGGTGGCAAGAAA
TGGGCTACATTTTCTACCCCAGAAAATTACGATAACCCTTATGAAACCTAAGGGTCGAAG
GTGGATTTAGCAGTAAACTAAGAGTAGAGTGCTTAGTTGAACAGGGCCCTGAAGCGCGTA
CACACCGCCCGTCACCCTCCTCAAGTATACTTCAAAGGATACTTAACTTAAACCCCCTAC
GTATTTATATAGAGGAGATAAGTCGTAACATGGTAAGTGTACTGGAAAGTGCACTTGGAC
GAACCAGAGTGTAGCTTAACATAAAGCACCCAACTTACACTTAGGAGATTTCAACTCAAC
TTGACCACTCTGAGCCAAACCTAGCCCCAAACCCCCTCCACCCTACTACCAAACAACCTT
AACCAAACCATTTACCCAAATAAAGTATAGGCGATAGAAATTGTAAACCGGCGCAATAGA
CATAGTACCGCAAGGGAAAGATGAAAAATTATACCCAAGCATAATACAGCAAGGACTAAC
CCCTGTACCTTTTGCATAATGAATTAACTAGAAATAACTTTGCAAAGAGAACCAAAGCTA
AGACCCCCGAAACCAGACGAGCTACCTAAGAACAGCTAAAAGAGCACACCCGTCTATGTA
GCAAAATAGTGGGAAGATTTATAGGTAGAGGCGACAAACCTACCGAGCCTGGTGATAGCT
GGTTGTCCAAGATAGAATCTTAGTTCAACTTTAAATTTACCTACAGAACCCTCTAAATCC
CCTTGTAAATTTAACTGTTAGTCCAAAGAGGAACAGCTCTTTAGACACTAGGAAAAAACC
TTGTAAAGAGAGTAAAAAATTTAACACCCATAGTAGGCCTAAAAGCAGCCACCAATTAAG
AAAGCGTTCAAGCTCAACACCCACAACCTTAAAGATCCCAAACATACAACCGAACTCCTT
ACACCCAATTGGACCAATCTATTACCCCATAGAAGAACTAATGTTAGTATAAGTAACATG
AAAACATTCTCCTCCGCATAAGCCTACATCAGACCAAAATATTAAACTGACAATTAACAG
CCTAATATCTACAATCAACCAACAAGCCATTATTACCCCCGCTGTTAACCCAACACAGGC
ATGCCCACAAGGAAAGGTTAAAAAAAGTAAAAGGAACTCGGCAAATCTTACCCCGCCTGT
TTACCAAAAACATCACCTCTAGCATTACCAGTATTAGAGGCACCGCCTGCCCGGTGACAT
ATGTTTAACGGCCGCGGTACCCTAACCGTGCAAAGGTAGCATAATCACTTGTTCCTTAAA
TAGGGACTTGTATGAATGGCTCCACGAGGGTTTAGCTGTCTCTTACTTTCAACCAGTGAA
ATTGACCTACCCGTGAAGAGGCGGGCATAACATAACAAGACGAGAAGACCCTATGGAGCT
TTAATTCATTAATGCAAACAATACTTAACAAACCTACAGGTCCTAAACTATTAAACCTGC
ATTAAAAATTTCGGTTGGGGCGACCTCGGAGCACAACCCAACCTCCGAGCAATACATGCT
AAGACCTCACCAGTCAAAGCGAATTACTACATCCAATTGATCCAATGACTTGACCAACGG
AACAAGTTACCCTAGGGATAACAGCGCAATCCTATTCCAGAGTCCATATCAACAATAGGG
TTTACGACCTCGATGTTGGATCAGGACATCCCGATGGTGCAGCCGCTATTAAAGGTTCGT
TTGTTCAACGATTAAAGTCCTACGTGATCTGAGTTCAGACCGGAGTAATCCAGGTCGGTT
TCTATCTGTTCTAAATTTCTCCCTGTACGAAAGGACAAGAGAAATGAGGCCTACTTCACA
AAGCGCCTTCCCCAATAAATGATATTATCTCAATTTAACGCCATGCCAACACCCACTCAA
GAACAGAGTTTGTTAAGATGGCAGAGCCCGGTAATTGCATAAAACTTAAAACTTTACAAT
CAGAGGTTCAATTCCTCTTCTTGACAACACACCCATGACCAACCTCCTACTCCTCATTGT
ACCCATCCTAATCGCAATAGCATTCCTAATGCTAACCGAACGAAAAATTCTAGGCTACAT
ACAACTACGCAAAGGTCCCAACATTGTAGGTCCTTACGGGCTATTACAGCCCTTCGCTGA
CGCCATAAAACTCTTCACTAAAGAACCCTTAAAACCCTCCACTTCAACCATTACCCTCTA
CATCACCGCCCCAACCCTAGCCCTCACCATTGCCCTCTTACTATGAACCCCCCTCCCCAT
ACCCAACCCCCTAGTCAATCTTAACTTAGGCCTCCTATTTATTCTAGCCACCTCCAGCCT
AGCCGTTTACTCAATCCTCTGATCAGGGTGAGCATCAAACTCGAACTACGCCTTAATCGG
TGCACTACGAGCAGTAGCCCAAACAATCTCATACGAAGTCACTCTAGCCATTATCCTACT
GTCAACGCTACTAATAAGTGGCTCCTTCAATCTCTCTACCCTTGTCACAACACAAGAGCA
CCTCTGACTAATCCTGCCAACATGACCCCTGGCCATAATATGATTTATCTCTACACTAGC
AGAGACCAACCGGACTCCCTTCGACCTTACTGAAGGAGAATCTGAACTAGTCTCAGGCTT
TAATATCGAGTATGCCGCAGGCCCCTTTGCCCTATTTTTCATAGCCGAATACATAAACAT
TATTATAATAAACACCCTCACTGCTACAATCTTCCTAGGAACAACATACAATACGCACTC
CCCTGAACTCTACACGACATATTTTGTCACCAAAGCTCTACTTCTAACCTCCCTGTTCCT
ATGAATTCGAACAGCATATCCCCGATTTCGCTACGACCAGCTCATACACCTCCTATGAAA
AAACTTCCTACCACTCACCCTAGCATCACTCATGTGATATATCTCCATACCCACTACAAT
CTCCAGCATCCCCCCTCAAACCTAAGAAATATGTCTGATAAAAGAATTACTTTGATAGAG
TAAATAATAGGAGTTCAAATCCCCTTATTTCTAGGACTATAAGAATCGAACTCATCCCTG
AGAATCCAAAATTCTCCGTGCCACCTATCACACCCCATCCTAAAGTAAGGTCAGCTAAAT
AAGCTATCGGGCCCATACCCCGAAAATGTTGGTTACACCCTTCCCGTACTAATTAATCCC
CTAGCCCAACCCATCATCTACTCTACCATCCTTACAGGCACGCTCATTACAGCGCTAAGC
TCACACTGATTTTTCACCTGAGTAGGCCTAGAAATAAATATACTAGCTTTTATCCCAATC
CTAACCAAAAAAATAAGCCCCCGCTCCACAGAAGCCGCCATCAAATACTTTCTCACACAA
GCAACTGCGTCCATAATTCTCCTGATAGCTATCCTCTCCAACAGCATACTCTCCGGACAA
TGAACCATAACCAATACTACCAATCAATACTCATCATTAATAATTATAATAGCAATGGCA
ATAAAACTAGGAATAGCCCCCTTTCACTTTTGAGTTCCAGAAGTTACCCAAGGCACCCCC
CTAATATCCGGCCTACTCCTCCTCACATGACAAAAATTAGCCCCTATTTCAATTATATAC
CAAATCTCCTCATCACTGAACGTAAACCTTCTCCTCACCCTTTCAATCTTGTCCATTATA
GCAGGCAGCTGAGGCGGACTAAACCAAACCCAACTACGCAAAATCCTAGCATACTCCTCA
ATCACCCACATAGGCTGAATAATAGCAGTCCTACCATATAACCCTAACATAACCATTCTT
AATTTAACCATTTACATCATCCTAACTACTACCGCATTTCTGCTACTCAACTTAAACTCC
AGCACCACAACCCTACTACTATCTCGCACCTGAAACAAGCTAACATGATTAACTCCCCTA
ATTCCATCCACCCTCCTCTCCCTAGGAGGCCTACCCCCACTAACTGGCTTCTTACCCAAA
TGAGTTATCATCGAAGAATTCACAAAAAATAATAGCCTCATCATCCCCACCATCATAGCC
ATCATCACTCTCCTTAACCTCTATTTCTACCTACGCCTAATCTACTCCACCTCAATTACA
CTACTTCCCATATCTAATAACGTAAAAATAAAATGACAATTCGAACATACAAAACCCACC
CCCTTCCTCCCTACACTCATCACCCTTACCACACTGCTTCTACCCATCTCCCCCTTCATA
CTAATAATCTTATAGAAATTTAGGTTAAGCACAGACCAAGAGCCTTCAAAGCCCTCAGCA
AGTTACAATACTTAATTTCTGCAACAACTAAGGACTGCAAAACCCCACTCTGCATCAACT
GAACGCAAATCAGCCACTTTAATTAAGCTAAGCCCTTACTAGATTAATGGGACTTAAACC
CACAAACATTTAGTTAACAGCTAAACACCCTAATCAACTGGCTTCAATCTACTTCTCCCG
CCGCAAGAAAAAAAGGCGGGAGAAGCCCCGGCAGGTTTGAAGCTGCTTCTTCGAATTTGC
AATTCAATATGAAAATCACCTCAGAGCTGGTAAAAAGAGGCTTAACCCCTGTCTTTAGAT
TTACAGTCCAATGCTTCACTCAGCCATTTTACCCCACCCTACTGATGTTCACCGACCGCT
GACTATTCTCTACAAACCACAAAGATATTGGAACACTATACCTACTATTCGGTGCATGAG
CTGGAGTCCTGGGCACAGCCCTAAGTCTCCTTATTCGGGCTGAACTAGGCCAACCAGGCA
ACCTCCTAGGTAATGACCACATCTACAATGTCATCGTCACAGCCCATGCATTCGTAATAA
TCTTCTTCATAGTAATGCCTATTATAATCGGAGGCTTTGGCAACTGGCTAGTTCCCTTGA
TAATTGGTGCCCCCGACATGGCATTCCCCCGCATAAACAACATAAGCTTCTGGCTCCTGC
CCCCTTCTCTCCTACTTCTACTTGCATCTGCCATAGTAGAAGCCGGCGCCGGAACAGGTT
GAACAGTCTACCCTCCCTTAGCGGGAAACTACTCGCATCCTGGAGCCTCCGTAGACCTAA
CCATCTTCTCCTTACATCTGGCAGGCATCTCCTCTATCCTAGGAGCCATTAACTTCATCA
CAACAATTATTAATATAAAACCTCCTGCCATGACCCAATACCAAACACCCCTCTTCGTCT
GATCCGTCCTAATCACAGCAGTCTTACTTCTCCTATCCCTCCCAGTCCTAGCTGCTGGCA
TCACCATACTATTGACAGATCGTAACCTCAACACTACCTTCTTCGACCCAGCCGGGGGAG
GAGACCCTATTCTATATCAACACTTATTCTGATTTTTTGGCCACCCCGAAGTTTATATTC
TTATCCTACCAGGCTTCGGAATAATTTCCCACATTGTAACTTATTACTCCGGAAAAAAAG
AACCATTTGGATATATAGGCATGGTTTGAGCTATAATATCAATTGGCTTCCTAGGGTTTA
TCGTGTGAGCACACCATATATTTACAGTAGGGATAGACGTAGACACCCGAGCCTATTTCA
CCTCCGCTACCATAATCATTGCTATTCCTACCGGCGTCAAAGTATTCAGCTGACTCGCTA
CACTTCACGGAAGCAATATGAAATGATCTGCCGCAGTACTCTGAGCCCTAGGGTTTATCT
TTCTCTTCACCGTAGGTGGCCTAACCGGCATTGTACTAGCAAACTCATCATTAGACATCG
TGCTACACGACACATACTACGTCGTAGCCCACTTCCACTACGTTCTATCAATAGGAGCTG
TATTCGCCATCATAGGAGGCTTCATTCACTGATTCCCCCTATTCTCAGGCTATACCCTAG
ACCAAACCTATGCCAAAATCCAATTTGCCATCATGTTCATTGGCGTAAACCTAACCTTCT
TCCCACAGCACTTCCTTGGCCTATCTGGGATGCCCCGACGTTACTCGGACTACCCCGATG
CATACACCACATGAAATGTCCTATCATCCGTAGGCTCATTTATCTCCCTGACAGCAGTAA
TATTAATAATTTTCATGATTTGAGAAGCCTTTGCTTCAAAACGAAAAGTCCTAATAGTAG
AAGAGCCCTCCGCAAACCTGGAATGACTATATGGATGCCCCCCACCCTACCACACATTCG
AAGAACCCGTATACATAAAATCTAGACAAAAAAGGAAGGAATCGAACCCCCTAAAGCTGG
TTTCAAGCCAACCCCATGACCTCCATGACTTTTTCAAAAAGATATTAGAAAAACTATTTC
ATAACTTTGTCAAAGTTAAATTACAGGTTAACCCCCGTATATCTTAATGGCACATGCAGC
GCAAGTAGGTCTACAAGATGCTACTTCCCCTATCATAGAAGAACTTATTATCTTTCACGA
CCATGCCCTCATAATTATCTTTCTCATCTGCTTTCTAGTCCTATACGCCCTTTTCCTAAC
ACTCACAACAAAACTAACTAATACTAGTATTTCAGACGCCCAGGAAATAGAAACCGTCTG
AACTATCCTGCCCGCCATCATCCTAGTCCTTATTGCCCTACCATCCCTGCGTATCCTTTA
CATAACAGACGAGGTCAACGACCCCTCCTTTACTATTAAATCAATCGGCCATCAATGATA
TTGAACCTACGAATACACCGACTACGGCGGGCTAATCTTCAACTCCTACATACTCCCCCC
ATTATTTCTAGAACCAGGTGATCTACGACTCCTTGACGTTGATAACCGAGTGGTCCTCCC
AGTTGAAGCCCCCGTTCGTATAATAATTACATCACAAGATGTTCTACACTCATGAGCTGT
TCCCACATTAGGCCTAAAAACAGACGCAATTCCCGGACGCCTAAACCAAACCACTTTCAC
CGCCACACGACCAGGAGTATACTACGGCCAATGCTCAGAAATCTGTGGAGCAAACCACAG
TTTTATACCCATCGTCCTAGAATTAATCCCTCTAAAAATCTTTGAAATAGGACCCGTATT
CACTCTATAGCACCTTCTCTACCCCTCTCCAGAGCTCACTGTAAAGCTAACCTAGCATTA
ACCTTTTAAGTTAAAGATTAAGAGGACCGACACCTCTTTACAGTGAAATGCCCCAACTAA
ATACCGCCGTATGACCCACCATAATTACCCCCATACTCCTGACACTATTTCTCGTCACCC
AACTAAAAATATTAAATTCAAATTACCATCTACCCCCCTCACCAAAACCCATAAAAATAA
AAAACTACAATAAACCCTGAGAACCAAAATGAACGAAAATCTATTCGCTTCATTCGCTGC
CCCCACAATCCTAGGCTTACCCGCCGCAGTACTAATCATTCTATTCCCCCCTCTACTGGT
CCCCACTTCTAAACATCTCATCAACAACCGACTAATTACCACCCAACAATGACTAATTCA
ACTGACCTCAAAACAAATAATAACTATACACAGCACTAAAGGACGAACCTGATCTCTCAT
ACTAGTATCCTTAATCATTTTTATTACCACAACCAATCTTCTTGGACTTCTACCCCACTC
ATTCACACCAACCACCCAACTATCTATAAACCTAGCCATGGCTATCCCCCTATGAGCAGG
CGCAGTAGTCATAGGCTTTCGCTTTAAGACTAAAAATGCCCTAGCCCACTTCTTACCGCA
AGGCACACCTACACCCCTTATCCCCATACTAGTTATCATCGAAACTATTAGCCTACTCAT
TCAACCAATAGCCTTAGCCGTACGTCTAACCGCTAACATTACTGCAGGCCACCTACTCAT
GCACCTAATTGGAAGCGCCACACTAGCATTATCAACTATCAATCTACCCTCTGCACTCAT
TATCTTCACAATTCTAATCCTACTGACTATTCTAGAGATCGCCGTCGCCTTAATCCAAGC
CTACGTTTTTACACTTCTAGTGAGCCTCTACCTGCACGACAACACATAATGACCCACCAA
TCACATGCCTACCACATAGTAAAACCCAGCCCATGACCCCTAACAGGGGCCCTCTCGGCC
CTCCTAATAACCTCCGGCCTGGCCATATGATTCCACTTCTACTCCACAACACTACTCACA
CTAGGCTTACTAACTAACACATTGACCATATATCAATGATGACGCGATGTTATACGAGAA
GGCACATACCAAGGCCACCACACACCACCCGTCCAAAAAGGTCTCCGATATGGGATAATT
CTTTTTATTACCTCAGAAGTTTTTTTCTTTGCAGGATTTTTTTGAGCTTTCTACCACTCC
AGCCTAGCCCCTACCCCCCAGCTAGGAGGACACTGGCCCCCAACAGGTATTACCCCACTA
AATCCCCTAGAAGTCCCACTCCTAAACACATCTGTATTACTCGCATCAGGAGTATCAATT
ACTTGAGCCCATCACAGCTTAATAGAAAATAACCGAAACCAAATAATTCAAGCACTGCTT
ATTACGATTCTACTAGGTCTTTATTTTACCCTCCTACAAGCCTCAGAATATTTCGAATCC
CCTTTTACCATTTCCGATGGCATCTACGGCTCAACATTCTTTGTAGCCACAGGCTTCCAC
GGACTCCACGTCATTATTGGATCAACTTTCCTCACTATCTGCCTCATCCGCCAACTAATA
TTTCACTTCACATCCAAACATCACTTCGGCTTTGAAGCCGCCGCCTGATACTGACACTTC
GTAGATGTAGTCTGACTATTTCTATATGTCTCTATTTACTGATGAGGATCTTACTCTTTT
AGTATAAGTAGTACCGTTAACTTCCAATTAACTAGTTTTGACAACATTCAAAAAAGAGTA
ATAAACTTCGTCCTAATTTTAATAACCAATACCCTTCTAGCCCTACTACTGATAATTATC
ACATTCTGACTACCACAACTCAACAGCTACATAGAAAAATCTAACCCTTACGAATGTGGC
TTCGACCCTATATCCCCCGCCCGCGTCCCCTTCTCCATAAAATTTTTCCTAGTAGCCATC
ACCTTCCTATTATTTGACCTAGAAATTGCCCTCCTATTGCCCTTACCTTGAGCCCTACAA
ACGGCCAACCTACCACTAATAGTCATATCATCCCTCTTATTAATTACTATCCTAGCCCTA
AGCCTCGCCTACGAATGATTACAAAAAGGGTTAGACTGAACCGAATTGGTATATAGTTTA
AATAAAACGAATGATTTCGACTCATTAAATTATGATAATCATATTTACCAAATGCCCCTT
ATTTATATAAATATTATACTAGCATTTACCATCTCACTTCTAGGAATACTAGTATATCGC
TCACACCTAATATCTTCCCTACTATGCCTAGAAGGAATAATACTATCACTGTTCATCATA
GCCACCCTCATAACCCTCAATACTCACTCCCTCTTAGCCAATATTGTACCCATCACCATA
CTAGTCTTTGCTGCCTGCGAAGCAGCAGTAGGTCTAGCACTACTAGTTTCAATCTCTAAC
ACATATGGCTTAGACTACGTACATAACCTAAACCTACTCCAATGCTAAAACTAATCATCC
CGACAATTATATTACTACCACTAACATGATTCTCTAAAAAACGTATAATTTGAATCAACA
CAACCACTCACAGCCTAATTATCAGCACCATTCCCTTACTATTTTTTAACCAAATTAACA
ACAACCTATTCAGCTGTTCCCTGCCCTTCTCCTCCGACCCCTTAACAACTCCCCTCCTAA
TATTAACTGCTTGACTTCTACCCCTCACAATCATAGCAAGCCAGCGCCACCTATCCAACG
AACCACTATCACGAAAAAAACTCTACCTCTCCATGCTAATTTCCCTCCAAATCTCCTTAA
TTATAACATTCTCGGCCACAGAGCTAATTATATTTTATATCTTCTTCGAAACCACACTTA
TCCCCACCCTGGCTATCATCACCCGATGGGGTAACCAACCAGAACGCCTGAACGCAGGTA
CATACTTCCTATTCTATACCCTAGTAGGCTCCCTCCCCCTACTCATCGCACTAATCTATA
CCCACAACACCCTAGGCTCACTAAATATCCTATTACTCACTCTTACAACCCAAGAACTAT
CAAACACCTGAGCCAACAACTTAATATGACTAGCGTACACGATGGCTTTCATGGTAAAAA
TACCCCTTTACGGACTCCACCTATGACTCCCTAAAGCCCATGTCGAAGCCCCTATTGCCG
GGTCAATGGTACTTGCTGCAGTACTCTTAAAATTAGGTGGCTATGGCATAATACGCCTCA
CACTCATCCTCAACCCCCTAACAAAACATATAGCCTATCCCTTCCTCATGTTGTCCTTAT
GAGGTATAATCATAACAAGCTCCATCTGCCTGCGACAAACAGACCTAAAATCGCTCATTG
CATACTCTTCAGTCAGCCACATAGCCCTCGTAGTAACAGCCATTCTCATCCAAACCCCCT
GAAGCTTCACCGGCGCAATTATCCTCATAATCGCCCACGGACTTACATCCTCATTATTAT
TCTGCCTAGCAAACTCAAATTATGAACGCACCCACAGTCGCATCATAATTCTCTCCCAAG
GACTTCAAACTCTACTCCCACTAATAGCCTTTTGATGACTCCTGGCAAGCCTCGCTAACC
TCGCCCTACCCCCTACCATTAATCTCCTAGGGGAACTCTCCGTGCTAGTAACCTCATTCT
CCTGATCAAATACCACTCTCCTACTCACAGGATTCAACATACTAATCACAGCCCTGTACT
CCCTCTACATGTTTACCACAACACAATGAGGCTCACTCACCCACCACATTAATAGCATAA
AGCCCTCATTCACACGAGAAAACACTCTCATATTTTTACACCTATCCCCCATCCTCCTTC
TATCCCTCAATCCTGATATCATCACTGGATTCACCTCCTGTAAATATAGTTTAACCAAAA
CATCAGATTGTGAATCTGACAACAGAGGCTCACGACCCCTTATTTACCGAGAAAGCTTAT
AAGAACTGCTAACTCGTATTCCCATGCCTAACAACATGGCTTTCTCAACTTTTAAAGGAT
AACAGTTATCCATTGGTCTTAGGCCCCAAAAATTTTGGTGCAACTCCAAATAAAAGTAAT
AACCATGTATGCTACCATAACCACCTTAGCCCTAACTTCCTTAATTCCCCCCATCCTCGC
CGCCCTCATTAACCCTAACAAAAAAAACTCATACCCCCATTACGTGAAATCCATTATCGC
ATCCACCTTTATCATTAGCCTTTTCCCCACAACAATATTCATATGCCTAGACCAAGAAAC
TATTATCTCGAACTGACACTGAGCAACAACCCAAACAACCCAACTCTCCCTGAGCTTTAA
ACTAGACTATTTCTCCATAACATTTATCCCCGTAGCACTGTTCGTTACATGATCCATCAT
AGAATTCTCACTATGATATATAGACTCAGACCCCAACATCAACCAATTCTTCAAATACTT
ACTTATCTTCCTAATTACTATACTAATCCTAGTCACCGCTAACAACCTATTCCAACTCTT
CATCGGCTGAGAAGGCGTAGGAATTATATCCTTTCTACTCATTAGCTGATGGTACGCCCG
AACAGATGCCAACACAGCAGCCATCCAAGCAATCCTATATAACCGTATCGGTGATATTGG
TTTTGTCCTAGCCCTAGCATGATTTCTCCTACACTCCAACTCATGAGACCCACAACAAAT
AATCCTCCTAAGTACTAATACAGACCTTACTCCACTACTAGGCTTCCTCCTAGCAGCAGC
AGGCAAATCAGCTCAACTAGGCCTTCACCCCTGACTCCCCTCAGCCATAGAAGGCCCTAC
TCCTGTTTCAGCCCTACTCCACTCAAGCACCATAGTCGTAGCAGGAATCTTCCTACTCAT
CCGCTTCTACCCCCTAGCAGAGAATAACCCACTAATCCAAACTCTCACGCTATGCCTAGG
CGCTATCACCACCCTATTCGCAGCAGTCTGCGCCCTCACACAAAATGACATCAAAAAAAT
CGTGGCCTTCTCCACTTCAAGCCAACTAGGACTCATAATAGTTACAATCGGTATCAACCA
ACCACACCTAGCATTCCTTCACATCTGCACCCACGCTTTCTTCAAAGCCATACTATTCAT
ATGCTCCGGATCCATTATTCACAACCTCAATAATGAGCAAGACATTCGAAAAATAGGAGG
ATTACTCAAAACCATACCCCTCACTTCAACCTCCCTCACCATTGGGAGCCTAGCATTAGC
AGGAATACCCTTCCTCACAGGTTTCTACTCCAAAGACCTCATCATCGAAACCGCTAACAT
ATCATACACAAACGCCTGAGCCCTATCTATTACTCTCATCGCCACCTCTCTGACAAGCGC
CTACAGCACCCGAATAATCCTCCTCACCCTAACAGGTCAACCTCGCTTCCCAACCCTCAC
CAACATTAACGAAAACAACCCCACTCTGTTAAATCCCATTAAACGCCTAACCATTGGAAG
CTTATTTGCAGGATTTCTCATTACCAACAACATTCTCCCCATATCTACTCCCCAAGTGAC
AATTCCCCTTTACTTAAAACTTACAGCCCTAGGCGTTACTTCCCTAGGACTTCTAACAGC
CCTAGACCTCAATTACCTAACCAGCAAGCTCAAAATAAAATCCCCACTATATACATTTCA
CTTCTCTAATATACTCGGATTCTACCCTAACATTATACACCGCTCGATCCCCTATCTAGG
CCTTCTTACAAGCCAAAACCTACCCCTACTTCTTCTAGACCTGACCTGACTAGAGAAACT
ATTACCTAAAACAATTTCACAGTACCAAATCTCCGCTTCCATTACCACCTCAACCCAAAA
AGGCATGATCAAACTTTATTTCCTCTCTTTTTTCTTCCCTCTCATCTTAACCTTACTCCT
AATCACATAACCTATTCCCCCGAGCAATCTCAATCACAATGTATACACCAACAAACAATG
TCCAACCAGTAACTACTACTAACCAACGCCCATAATCATATAAGGCCCCCGCACCAATAG
GATCCTCCCGAATCAGCCCTGGCCCCTCCCCTTCATAAATTATTCAACTTCCCACGCTAT
TAAAATTTACCACAACCACCATCCCATCATACCCTTTTACCCATAACACTAATCCTACCT
CCATCGCCAGTCCTACTAAAACACTAACCAAAACCTCAACCCCTGACCCCCATGCCTCAG
GATACTCCTCAATAGCCATAGCCGTAGTATACCCAAAAACAACCATTATTCCCCCCAAAT
AAATTAAAAAAACCATTAAACCTATATAACCTCCCCCATAATTCAAAATGATGGCACACC
CAACTACACCACTAACAATCAATACTAAACCCCCATAAATGGGAGAAGGCTTAGAAGAAA
ACCCCACAAACCCTATCACTAAACTCACACTCAATAAAAATAAAGCATATGTCATTATTC
TCGCACGGACTACAACCACGACCAATGATATGAAAAACCATCGTTGTATTTCAACTACAA
GAACACCAATGACCCCGACACGCAAAATTAACCCACTAATAAAATTAATTAATCACTCAT
TTATCGACCTCCCCACCCCATCCAACATTTCCGCATGATGGAACTTCGGCTCACTTCTCG
GCGCCTGCCTAATCCTTCAAATTACCACAGGATTATTCCTAGCTATACACTACTCACCAG
ACGCCTCAACCGCCTTCTCGTCGATCGCCCACATCACCCGAGACGTAAACTATGGTTGGA
TCATCCGCTACCTCCACGCTAACGGCGCCTCAATATTTTTTATCTGCCTCTTCCTACACA
TCGGCCGAGGTCTATATTACGGCTCATTTCTCTACCTAGAAACCTGAAACATTGGCATTA
TCCTCTTGCTCACAACCATAGCAACAGCCTTTATGGGCTATGTCCTCCCATGAGGCCAAA
TATCCTTCTGAGGAGCCACAGTAATTACAAACCTACTGTCCGCTATCCCATACATCGGAA
CAGACCTGGTCCAGTGAGTCTGAGGAGGCTACTCAGTAGACAGCCCTACCCTTACACGAT
TCTTCACCTTCCACTTTATCTTACCCTTCATCATCACAGCCCTAACAACACTTCATCTCC
TATTCTTACACGAAACAGGATCAAATAACCCCCTAGGAATCACCTCCCACTCCGACAAAA
TTACCTTCCACCCCTACTACACAATCAAAGATATCCTTGGCTTATTCCTTTTCCTCCTTA
TCCTAATGACATTAACACTATTCTCACCAGACCTCCTAGGCGATCCAGACAACTATACCC
TAGCTAACCCCCTAAACACCCCACCCCACATTAAACCCGAGTGATACTTTCTATTTGCCT
ACACAATCCTCCGATCCATCCCCAACAAACTAGGAGGCGTCCTCGCCCTACTACTATCTA
TCCTAATCCTAACAGCAATCCCTGTCCTCCACACATCCAAACAACAAAGCATAATATTTC
GCCCACTAAGCCAACTGCTTTACTGACTCCTAGCCACAGACCTCCTCATCCTAACCTGAA
TCGGAGGACAACCAGTAAGCTACCCCTTCATCACCATCGGACAAATAGCATCCGTATTAT
ACTTCACAACAATCCTAATCCTAATACCAATCGCCTCTCTAATCGAAAACAAAATACTTG
AATGAACCTGCCCTTGTAGTATAAACTAATACACCGGTCTTGTAAACCGGAAACGAAAAC
TTTCTTCCAAGGACAAATCAGAGAAAAAGTAATTAACTTCACCATCAGCACCCAAAGCTA
AGATTCTAATTTAAACTATTCTCTGTTCTTTCATGGGGAAGCAAATTTAAGTACCACCTA
AGTACTGGCTCATTCATTACAACCGCTATGTATTTCGTACATTACTGCCAGCCACCATGA
ATATTGTACAGTACCATAATCACCCAACCACCTATAGCACATAAAATCCACCTCACATCA
AAACCTTCACCCCATGCTTACAAGCACGCACAACAATCAACCCCCAACTATCGAACATAA
AACACAACTCCAACGACACTTCTCCCCCACCCTAATACCAACAAACCTACCCTCCCTTGA
CAAAACATAATACATACAATCACACACCGTACATAGCACATTACAGTCAAATCCATCCTT
GCCCCCACGGATGATCCCCCTCAGATGGGAATCCCTTGGCCACCATCCTCCGTGAAATCA
ATATCCCGCACAAGAGTACTACTCTCCTCGCTCCGGGCCCATAACATCTGGGGGTAGCTA
AAGTGAACTGTATCCGACATCTGGTTCCTACTTCAGGGCCATGAAGTTCAAAAGTCTCCC
ACACGTTCCCCTTAAATAAGACATCACGATGGATCACAGGTCTATCACCCTATTAACCAG
TCACGGGAGCCTTCCATGCATTTGGTATTTTCGTCTGGGGGGTGTGCACGCGATAGCATT
GCGAAACGCTGGCCCCGGAGCACCCTATGTCGCAGTATCTGTCTTTGATTCCTACCTCAT
TACATTATTTATCGCACCTACGTTCAATATTACGGCCCAGCATACCTATTGAAGCGTGTT
AATTAATTAATGCTTGTAGGACATAACAACAGCAGCAAAATGTTCACACAACCGCTTTCC
ACACCAACACATAACAAAAATTCCCACAAACCCCCCCCTCCCCCCGGCCACAGCACTCAA
ACACATCTCTGCCAAACCCCAAAAACAAAGAACCCAAACACCAGCCTGGCCAGACTTCAA
ATTTCATCTTTAGGCGGTATGCACTTTTAACAGTCACCCCTCAATTAACATGCCCTCCCC
CCTCAACTCCCATTCTACTAGCCCCAGCAACGTAACCCCCTACTCACCCCACTCAACACA
TACACCGCTGCTAACCCCATACCCTGAACCAACCAAACCCCAAAGACACCCCTACACA"
x <- paste(string1, collapse = "")
DNA_Sequence = unlist(strsplit(x, split = ""))
DNA_Sequence = DNA_Sequence[-which(DNA_Sequence == "\n")]

num = floor(length(DNA_Sequence)*0.7)
Seq = DNA_Sequence[1:num]

Coding_Sequence = c(rep("N",(2728-0)),
                    rep("C",(3684-2728)),
                    rep("N",(3891-3684)),
                    rep("C",(4933-3891)),
                    rep("N",(5324-4933)),
                    rep("C",(6866-5324)),
                    rep("N",(7006-6866)),
                    rep("C",(7690-7006)),
                    rep("N",(7787-7690)),
                    rep("C",(9412-7787)),
                    rep("N",(9480-9412)),
                    rep("C",(9826-9480)),
                    rep("N",(9891-9826)),
                    rep("C",(11559-9891)),
                    rep("N",(11758-11559)),
                    rep("C",(14095-11758)),
                    rep("N",(14168-14095)),
                    rep("C",(15309-14168)),
                    rep("N",(16558-15309)))

States_Hidden = c("N","C")
States_Observed = c("A","C","G","T")
hid_num = length(States_Hidden)
obs_num = length(States_Observed)

Known_Code_Seq = Coding_Sequence[1:num]
pii = c(1,0)

A_temp = matrix(rep(0,hid_num*hid_num), 
                nrow = hid_num, ncol = hid_num, byrow = TRUE)
a_n = 0
a_c = 0
for(i in 2:num)
{
  if(Known_Code_Seq[i] == "N")
  {
    a_n = a_n + 1
    if(Known_Code_Seq[i] == Known_Code_Seq[i-1])
    {
      A_temp[1,1] = A_temp[1,1] + 1
    }
  }else
  {
    a_c = a_c + 1
    if(Known_Code_Seq[i] == Known_Code_Seq[i-1])
    {
      A_temp[2,2] = A_temp[2,2] + 1
    }
  }
}
p_an = A_temp[1,1]/a_n
p_ac = A_temp[2,2]/a_c
A = matrix(c(p_an, 1 - p_an, 1 - p_ac, p_ac), 
           nrow = 2, ncol = 2, byrow = TRUE)

E_temp = matrix(rep(0,hid_num*obs_num), 
                nrow = hid_num, ncol = obs_num, byrow = TRUE)
e_n = 0
e_c = 0
for(i in 1:num)
{
  if(Known_Code_Seq[i] == "N")
  {
    e_n = e_n + 1
    if(Seq[i] == "A")
    {
      E_temp[1,1] = E_temp[1,1] + 1
    }else if(Seq[i] == "C")
    {
      E_temp[1,2] = E_temp[1,2] + 1
    }else if(Seq[i] == "G")
    {
      E_temp[1,3] = E_temp[1,3] + 1
    }else if(Seq[i] == "T")
    {
      E_temp[1,4] = E_temp[1,4] + 1
    }
  }else
  {
    e_c = e_c + 1
    if(Seq[i] == "A")
    {
      E_temp[2,1] = E_temp[2,1] + 1
    }else if(Seq[i] == "C")
    {
      E_temp[2,2] = E_temp[2,2] + 1
    }else if(Seq[i] == "G")
    {
      E_temp[2,3] = E_temp[2,3] + 1
    }else if(Seq[i] == "T")
    {
      E_temp[2,4] = E_temp[2,4] + 1
    }
  }
}
p_en = E_temp[1,]/e_n
p_ec = E_temp[2,]/e_c
E = matrix(c(p_en, p_ec), 
           nrow = hid_num, ncol = obs_num, byrow = TRUE)

#####
Init_HMM = function(States, Observations, Transition_prob = NULL, 
                    Emission_prob = NULL, Initial_prob = NULL)
{
  n_States = length(States)
  n_Observations = length(Observations)
  
  pii = rep(1/n_States,n_States)
  A = matrix(rep(1/(n_States),n_States*n_States),
             nrow = n_States,ncol = n_States,byrow = TRUE)
  E = matrix(rep(1/(n_Observations),n_States*n_Observations),
             nrow = n_States,ncol = n_Observations,byrow = TRUE)
  names(pii) = States
  rownames(A) = States
  colnames(A) = States
  rownames(E) = States
  colnames(E) = Observations
  return(list(States = States, Observations = Observations, 
              Transition_prob = A, Emission_prob = E, Initial_prob = pii))
}

Sub_HMM = function(HMM,pii,A,E)
{
  names(pii) = HMM$States
  rownames(A) = HMM$States
  colnames(A) = HMM$States
  rownames(E) = HMM$States
  colnames(E) = HMM$Observations
  
  HMM$Transition_prob = A
  HMM$Emission_prob = E
  HMM$Initial_prob = pii
  
  return(HMM)
}

#####
HMM = Init_HMM(States_Hidden, States_Observed)
HMM = Sub_HMM(HMM,pii,A,E)

#####
Forward = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  Alpha = matrix(c(rep(0,n_States*n_Observed_Seq)), 
                 nrow = n_States, ncol = n_Observed_Seq, byrow = TRUE)
  rownames(Alpha) = HMM$States
  colnames(Alpha) = Observed_Seq
  
  for(t in 1:n_Observed_Seq)
  {
    for(state in HMM$States)
    {
      if(t == 1)
      {
        Alpha[state,t] = 
          HMM$Initial_prob[state]*
          HMM$Emission_prob[state,Observed_Seq[t]]
      }else
      {
        sum_temp = 0
        for(previous_state in HMM$States)
        {
          temp = Alpha[previous_state,t-1]*
            HMM$Transition_prob[previous_state,state]
          if(temp>0)
          {
            sum_temp = temp + sum_temp
          }
        }
        Alpha[state,t] = sum_temp *
          HMM$Emission_prob[state,Observed_Seq[t]]
      }
    }
  }
  return(Alpha)
}

Backward = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  Beta = matrix(c(rep(0,n_States*n_Observed_Seq)), 
                nrow = n_States, ncol = n_Observed_Seq, byrow = TRUE)
  rownames(Beta) = HMM$States
  colnames(Beta) = Observed_Seq
  
  for(t in n_Observed_Seq:1)
  {
    for(state in HMM$States)
    {
      if(t == n_Observed_Seq)
      {
        Beta[state,t] = 1
      }else
      {
        sum_temp = 0
        for(next_state in HMM$States)
        {
          temp = Beta[next_state,t+1]*
            HMM$Emission_prob[next_state,Observed_Seq[t+1]]*
            HMM$Transition_prob[state,next_state]
          if(temp>0)
          {
            sum_temp = temp + sum_temp
          }
        }
        Beta[state,t] = sum_temp
      }
    }
  }
  return(Beta)
}

#####
Viterbi = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  v = matrix(c(rep(0,n_States*n_Observed_Seq)), 
             nrow = n_States, ncol = n_Observed_Seq, byrow = TRUE)
  rownames(v) = HMM$States
  colnames(v) = Observed_Seq
  
  for(t in 1:n_Observed_Seq)
  {
    for(state in HMM$States)
    {
      maximum = NULL
      if(t == 1)
      {
        v[state,t] = HMM$Initial_prob[state]*
          HMM$Emission_prob[state,Observed_Seq[t]]
      }else
      {
        for(previous_state in HMM$States)
        {
          temp = v[previous_state,t-1]*
            HMM$Transition_prob[previous_state,state]
          maximum = max(maximum,temp)
        }
        v[state,t] = HMM$Emission_prob[state,Observed_Seq[t]]*maximum
      }
    }
  }
  v_Path = rep(0,n_Observed_Seq)
  for(t in n_Observed_Seq:1)
  {
    for(state in HMM$States)
    {
      if(t == n_Observed_Seq)
      {
        if(max(v[,t]) == v[state,t])
        {
          v_Path[t] = state
          break
        }
      }else
      {
        if(max(v[,t]*HMM$Transition_prob[,v_Path[t+1]]) ==
           v[state,t]*HMM$Transition_prob[state,v_Path[t+1]])
        {
          v_Path[t] = state
          break
        }
      }
    }
  }
  return(v_Path)
}

Viterbi_Training_Recursion = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  
  TransitionMatrix    = HMM$Transition_prob
  TransitionMatrix[,] = 0
  EmissionMatrix      = HMM$Emission_prob
  EmissionMatrix[,]   = 0
  
  v = Viterbi(HMM, Observed_Seq)
  
  for(i in 1:(n_Observed_Seq-1))
  {
    TransitionMatrix[v[i],v[i+1]] = 
      TransitionMatrix[v[i],v[i+1]] + 1
  }
  for(i in 1:n_Observed_Seq)
  {
    EmissionMatrix[v[i],Observed_Seq[i]] = 
      EmissionMatrix[v[i],Observed_Seq[i]] + 1
  }
  HMM$Transition_prob = TransitionMatrix
  HMM$Emission_prob = EmissionMatrix
  return(HMM)
}

Viterbi_Training = function(HMM, Observed_Seq, maxIterations=100, delta=1E-9, pseudoCount=0)
{
  tempHmm = HMM
  tempHmm$Transition_prob[is.na(HMM$Transition_prob)] = 0
  tempHmm$Emission_prob[is.na(HMM$Emission_prob)] = 0
  diff = c()
  
  for(i in 1:maxIterations)
  {
    vt = Viterbi_Training_Recursion(tempHmm, Observed_Seq)
    TransitionMatrix = vt$Transition_prob
    EmissionMatrix = vt$Emission_prob
    
    TransitionMatrix[!is.na(HMM$Transition_prob)] = 
      TransitionMatrix[!is.na(HMM$Transition_prob)] + pseudoCount
    EmissionMatrix[!is.na(HMM$Emission_prob)] = 
      EmissionMatrix[!is.na(HMM$Emission_prob)] + pseudoCount
    
    TransitionMatrix = (TransitionMatrix/apply(TransitionMatrix,1,sum))
    EmissionMatrix = (EmissionMatrix/apply(EmissionMatrix,1,sum))
    
    d = sqrt(sum((tempHmm$Transition_prob-TransitionMatrix)^2))+ 
      sqrt(sum((tempHmm$Emission_prob-EmissionMatrix)^2))
    diff = c(diff, d)
    
    tempHmm$Transition_prob = TransitionMatrix
    tempHmm$Emission_prob = EmissionMatrix
    
    if(d<delta)
    {
      break
    }
  }
  
  tempHmm$Transition_prob[is.na(HMM$Transition_prob)] = NA
  tempHmm$Emission_prob[is.na(HMM$Emission_prob)] = NA
  return(list(HMM=tempHmm,difference=diff))
}

#####
Baum_Welch_Recursion = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  
  TransitionMatrix    = HMM$Transition_prob
  TransitionMatrix[,] = 0
  EmissionMatrix      = HMM$Emission_prob
  EmissionMatrix[,]   = 0
  
  f = Forward(HMM, Observed_Seq)
  b = Backward(HMM, Observed_Seq)
  
  prob_Observations = f[1,n_Observed_Seq]
  for(i in 2:n_States)
  {
    m = f[i,n_Observed_Seq]
    if(m > 0)
    {
      prob_Observations = m + prob_Observations
    }
  }
  
  for(i in HMM$States)
  {
    for(j in HMM$States)
    {
      temp = 0
      for(k in 1:(n_Observed_Seq-1))
      {
        m = f[i,k]*HMM$Transition_prob[i,j]*
          HMM$Emission_prob[j,Observed_Seq[k+1]]*b[j,k+1]
        if(m>0)
        {
          temp = m + temp
        }
      }
      temp = temp/prob_Observations
      TransitionMatrix[i,j] = temp
    }
  }
  for(i in HMM$States)
  {
    for(j in HMM$Observations)
    {
      temp = 0
      for(k in 1:n_Observed_Seq)
      {
        if(j == Observed_Seq[k])
        {
          m = f[i,k] * b[i,k]
          if(m>0)
          {
            temp = m + temp
          }
        }
      }
      temp = temp/prob_Observations
      EmissionMatrix[i,j] = temp
    }
  }
  
  HMM$Transition_prob = TransitionMatrix
  HMM$Emission_prob = EmissionMatrix
  return(HMM)
}

Baum_Welch = function(HMM, Observed_Seq, maxIterations=100, delta=1E-9, pseudoCount=0)
{
  tempHmm = HMM
  tempHmm$Transition_prob[is.na(HMM$Transition_prob)] = 0
  tempHmm$Emission_prob[is.na(HMM$Emission_prob)] = 0
  diff = c()
  
  for(i in 1:maxIterations)
  {
    bw = Baum_Welch_Recursion(tempHmm, Observed_Seq)
    TransitionMatrix = bw$Transition_prob
    EmissionMatrix = bw$Emission_prob
    
    TransitionMatrix[!is.na(HMM$Transition_prob)] = 
      TransitionMatrix[!is.na(HMM$Transition_prob)] + pseudoCount
    EmissionMatrix[!is.na(HMM$Emission_prob)] = 
      EmissionMatrix[!is.na(HMM$Emission_prob)] + pseudoCount
    
    TransitionMatrix = (TransitionMatrix/
                          apply(TransitionMatrix,MARGIN=1,FUN=sum))
    EmissionMatrix = (EmissionMatrix/
                        apply(EmissionMatrix,MARGIN=1,FUN=sum))
    
    d = sqrt(sum((tempHmm$Transition_prob-TransitionMatrix)^2))+ 
      sqrt(sum((tempHmm$Emission_prob-EmissionMatrix)^2))
    diff = c(diff, d)
    
    tempHmm$Transition_prob = TransitionMatrix
    tempHmm$Emission_prob = EmissionMatrix
    
    if(d < delta)
    {
      break
    }
  }
  
  tempHmm$Transition_prob[is.na(HMM$Transition_prob)] = NA
  tempHmm$Emission_prob[is.na(HMM$Emission_prob)] = NA
  return(list(HMM=tempHmm,difference=diff))
}

#####
Forward_log = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  Alpha = matrix(c(rep(0,n_States*n_Observed_Seq)), 
                 nrow = n_States, ncol = n_Observed_Seq, byrow = TRUE)
  rownames(Alpha) = HMM$States
  colnames(Alpha) = Observed_Seq
  
  for(t in 1:n_Observed_Seq)
  {
    for(state in HMM$States)
    {
      if(t == 1)
      {
        Alpha[state,t] = log(HMM$Initial_prob[state] *
                               HMM$Emission_prob[state,Observed_Seq[t]])
      }else
      {
        sum_temp = - Inf
        for(previous_state in HMM$States)
        {
          temp = Alpha[previous_state,t-1] +
            log(HMM$Transition_prob[previous_state,state])
          if(temp > - Inf)
          {
            sum_temp = temp + log(1+exp(sum_temp-temp))
          }
        }
        Alpha[state,t] = sum_temp +
          log(HMM$Emission_prob[state,Observed_Seq[t]])
      }
    }
  }
  return(Alpha)
}

Backward_log = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  Beta = matrix(c(rep(0,n_States*n_Observed_Seq)), 
                nrow = n_States, ncol = n_Observed_Seq, byrow = TRUE)
  rownames(Beta) = HMM$States
  colnames(Beta) = Observed_Seq
  
  for(t in n_Observed_Seq:1)
  {
    for(state in HMM$States)
    {
      if(t == n_Observed_Seq)
      {
        Beta[state,t] = 0
      }else
      {
        sum_temp = -Inf
        for(next_state in HMM$States)
        {
          temp = Beta[next_state,t+1] + 
            log(HMM$Emission_prob[next_state,Observed_Seq[t+1]] * 
                  HMM$Transition_prob[state,next_state])
          if(temp > - Inf)
          {
            sum_temp = temp + log(1+exp(sum_temp-temp))
          }
        }
        Beta[state,t] = sum_temp
      }
    }
  }
  return(Beta)
}

Baum_Welch_Recursion_log = function(HMM, Observed_Seq)
{
  n_States = length(HMM$States)
  n_Observations = length(HMM$Observations)
  n_Observed_Seq = length(Observed_Seq)
  
  TransitionMatrix    = HMM$Transition_prob
  TransitionMatrix[,] = 0
  EmissionMatrix      = HMM$Emission_prob
  EmissionMatrix[,]   = 0
  
  f = Forward_log(HMM, Observed_Seq)
  b = Backward_log(HMM, Observed_Seq)
  
  prob_Observations = f[1,n_Observed_Seq]
  for(i in 2:n_States)
  {
    m = f[i,n_Observed_Seq]
    if(m > -Inf)
    {
      prob_Observations = m + log(1+exp(prob_Observations-m))
    }
  }
  
  for(i in HMM$States)
  {
    for(j in HMM$States)
    {
      temp = f[i,1] + log(HMM$Transition_prob[i,j] * 
                            HMM$Emission_prob[j,Observed_Seq[1+1]]) + b[j,1+1]
      for(k in 2:(n_Observed_Seq-1))
      {
        m = f[i,k] + log(HMM$Transition_prob[i,j] * 
                           HMM$Emission_prob[j,Observed_Seq[k+1]]) + b[j,k+1]
        if(m > -Inf)
        {
          temp = m + log(1+exp(temp-m))
        }
      }
      temp = exp(temp - prob_Observations)
      TransitionMatrix[i,j] = temp
    }
  }
  for(i in HMM$States)
  {
    for(j in HMM$Observations)
    {
      temp = -Inf
      for(k in 1:n_Observed_Seq)
      {
        if(j == Observed_Seq[k])
        {
          m = f[i,k] + b[i,k]
          if(m > -Inf)
          {
            temp = m + log(1+exp(temp-m))
          }
        }
      }
      temp = exp(temp - prob_Observations)
      EmissionMatrix[i,j] = temp
    }
  }
  
  HMM$Transition_prob = TransitionMatrix
  HMM$Emission_prob = EmissionMatrix
  return(HMM)
}

Baum_Welch_log = function(HMM, Observed_Seq, maxIterations=100, delta=1E-9, pseudoCount=0)
{
  tempHmm = HMM
  tempHmm$Transition_prob[is.na(HMM$Transition_prob)] = 0
  tempHmm$Emission_prob[is.na(HMM$Emission_prob)] = 0
  diff = c()
  
  for(i in 1:maxIterations)
  {
    bw = Baum_Welch_Recursion_log(tempHmm, Observed_Seq)
    TransitionMatrix = bw$Transition_prob
    EmissionMatrix = bw$Emission_prob
    
    TransitionMatrix[!is.na(HMM$Transition_prob)] = 
      TransitionMatrix[!is.na(HMM$Transition_prob)] + pseudoCount
    EmissionMatrix[!is.na(HMM$Emission_prob)] = 
      EmissionMatrix[!is.na(HMM$Emission_prob)] + pseudoCount
    
    TransitionMatrix = (TransitionMatrix/
                          apply(TransitionMatrix,MARGIN=1,FUN=sum))
    EmissionMatrix = (EmissionMatrix/
                        apply(EmissionMatrix,MARGIN=1,FUN=sum))
    
    d = sqrt(sum((tempHmm$Transition_prob-TransitionMatrix)^2))+
      sqrt(sum((tempHmm$Emission_prob-EmissionMatrix)^2))
    diff = c(diff, d)
    
    tempHmm$Transition_prob = TransitionMatrix
    tempHmm$Emission_prob = EmissionMatrix
    
    if(d < delta)
    {
      break
    }
  }
  
  tempHmm$Transition_prob[is.na(HMM$Transition_prob)] = NA
  tempHmm$Emission_prob[is.na(HMM$Emission_prob)] = NA
  return(list(HMM=tempHmm,difference=diff))
}

Sim_HMM = function(HMM, length)
{
  HMM$Transition_prob[is.na(HMM$Transition_prob)] = 0
  HMM$Emission_prob[is.na(HMM$Emission_prob)] = 0
  states   = c()
  emission = c()
  states   = c(states, sample(HMM$States,1,prob = HMM$Initial_prob))
  for(i in 2:length)
  {
    state  = sample(HMM$States, 1, 
                    prob = HMM$Transition_prob[states[i-1],])
    states = c(states, state)
  }
  for(i in 1:length)
  {
    emi = sample(HMM$Observations, 1, 
                 prob = HMM$Emission_prob[states[i],])
    emission = c(emission, emi)
  }
  return(list(states=states,observation=emission))
}

#####
ZZZZ= function()
{
  number = 100
  zzz = numeric(number)
  for(zz in 1:number)
  {
    set.seed(zz)
    HMM_Trained = Baum_Welch_log(HMM,Seq)$HMM
    Gen_Seq = Sim_HMM(HMM_Trained,(length(DNA_Sequence)-num))
    test = sum(Gen_Seq$states == Coding_Sequence[(num+1):length(DNA_Sequence)])
    test_acc = test/length(Gen_Seq$states)
    zzz[zz] = test_acc
  }
  which(zzz == max(zzz))
  return(zzz)
}
#zzzzz = ZZZZ()
#plot(zzzzz, type = 'l', main = "Accuracy of 100 Baum-Welches", xlab = "Seed", ylab = "Accuracy")

set.seed(20)
HMM_Trained = Baum_Welch_log(HMM,Seq)$HMM
Gen_Seq = Sim_HMM(HMM_Trained,(length(DNA_Sequence)-num))

test1 = sum(Gen_Seq$states == Coding_Sequence[(num+1):length(DNA_Sequence)])
test1_acc = test1/length(Gen_Seq$states)

test2 = sum(Gen_Seq$observation == DNA_Sequence[(num+1):length(DNA_Sequence)])
test2_acc = test2/length(Gen_Seq$states)

t = length(Gen_Seq$states)
t3 = (t/3)
test3 = numeric(t3)
test4 = numeric(t3)
for(i in 1:t3)
{
  for(j in 1:3)
  {
    test3[i] = test3[i]+
      (Gen_Seq$observation[3*(i-1)+j] == 
      DNA_Sequence[num+3*(i-1)+j])
  }
  if(test3[i] >= 2)
  {
    test4[i] = 1
  }
}
test3_acc = sum(test3)/t
test4_acc = sum(test4)/t3

test1_acc
test2_acc
test3_acc
test4_acc

DNA_Predicted_Code = DNA_Sequence[num+which(Gen_Seq$states == "C")]
DNA_Real_Code = DNA_Sequence[num+which(Coding_Sequence[(num+1):length(DNA_Sequence)] == "C")]

minmax = max(min(which(Gen_Seq$states == "C")),min(which(Coding_Sequence[(num+1):length(DNA_Sequence)] == "C")))
maxmin = min(max(which(Gen_Seq$states == "C")),max(which(Coding_Sequence[(num+1):length(DNA_Sequence)] == "C")))

DNA_Predicted_Code = DNA_Sequence[num+(minmax:maxmin)]
DNA_Real_Code = DNA_Sequence[num+(minmax:maxmin)]

Check_Amino = function(a)
{
  Amino = ""
  
  if(a[1] == "A")
  {
    if(a[2] == "A" &
       (a[3] == "A" | a[3] == "G" ))
    {
      Amino = "Lys"
    }else if(a[2] == "A" &
             (a[3] == "C" | a[3] == "T" ))
    {
      Amino = "Asn"
    }else if(a[2] == "C")
    {
      Amino = "Thr"
    }else if(a[2] == "G" &
             (a[3] == "A" | a[3] == "G" ))
    {
      Amino = "Arg"
    }else if(a[2] == "G" &
             (a[3] == "C" | a[3] == "T" ))
    {
      Amino = "Ser"
    }else if(a[2] == "T" & 
             a[3] == "G")
    {
      Amino = "Met"
    }else
    {
      Amino = "Ile"
    }
  }else if(a[1] == "C")
  {
    if(a[2] == "A" &
       (a[3] == "A" | a[3] == "G" ))
    {
      Amino = "Gln"
    }else if(a[2] == "A" &
             (a[3] == "C" | a[3] == "T" ))
    {
      Amino = "His"
    }else if(a[2] == "C")
    {
      Amino = "Pro"
    }else if(a[2] == "G" )
    {
      Amino = "Arg"
    }else
    {
      Amino = "Leu"
    }
  }else if(a[1] == "G")
  {
    if(a[2] == "A" &
       (a[3] == "A" | a[3] == "G" ))
    {
      Amino = "Glu"
    }else if(a[2] == "A" &
             (a[3] == "C" | a[3] == "T" ))
    {
      Amino = "Asp"
    }else if(a[2] == "C")
    {
      Amino = "Ala"
    }else if(a[2] == "G" )
    {
      Amino = "Gly"
    }else
    {
      Amino = "Val"
    }
  }else
  {
    if(a[2] == "A" &
       (a[3] == "A" | a[3] == "G" ))
    {
      Amino = "STOP"
    }else if(a[2] == "A" &
             (a[3] == "C" | a[3] == "T" ))
    {
      Amino = "Tyr"
    }else if(a[2] == "C")
    {
      Amino = "Ser"
    }else if(a[2] == "G" &
             (a[3] == "A"))
    {
      Amino = "STOP"
    }else if(a[2] == "G" &
             (a[3] == "G"))
    {
      Amino = "Trp"
    }else if(a[2] == "G" &
             (a[3] == "C" | a[3] == "T"))
    {
      Amino = "Cys"
    }else if(a[2] == "T" &
             (a[3] == "A"| a[3] == "G"))
    {
      Amino = "Leu"
    }else
    {
      Amino = "Phe"
    }
  }
  return(Amino)
}

Protein = function(DNA_Real_Coding)
{
  numb = length(DNA_Real_Coding)-1
  Amino_acid_real = numeric(numb)
  
  Bool = FALSE
  j = 1
  while(j <= (numb/3 - 2))
  {
    i = 3*(j-1)+1
    if((DNA_Real_Coding[i] == "A") &
       (DNA_Real_Coding[i+1] == "T") &
       (DNA_Real_Coding[i+2] == "G"))
    {
      Bool = TRUE
    }
    
    if(Bool == TRUE)
    {
      Amino_acid_real[i] = 
        Check_Amino(DNA_Real_Coding[i:(i+2)])
    }
    
    if((DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "A" &
        DNA_Real_Coding[i+2] == "A") |
       (DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "A" &
        DNA_Real_Coding[i+2] == "G") |
       (DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "G" &
        DNA_Real_Coding[i+2] == "A"))
    {
      Bool = FALSE
    }
    
    j = j+1
  }
  
  Bool = FALSE
  j = 1
  while(j <= (numb/3 - 2))
  {
    i = 3*(j-1)+2
    if((DNA_Real_Coding[i] == "A") &
       (DNA_Real_Coding[i+1] == "T") &
       (DNA_Real_Coding[i+2] == "G"))
    {
      Bool = TRUE
    }
    
    if(Bool == TRUE)
    {
      Amino_acid_real[i] = 
        Check_Amino(DNA_Real_Coding[i:(i+2)])
    }
    
    if((DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "A" &
        DNA_Real_Coding[i+2] == "A") |
       (DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "A" &
        DNA_Real_Coding[i+2] == "G") |
       (DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "G" &
        DNA_Real_Coding[i+2] == "A"))
    {
      Bool = FALSE
    }
    
    j = j+1
  }
  
  Bool = FALSE
  j = 1
  while(j <= (numb/3 - 2))
  {
    i = 3*(j)
    if((DNA_Real_Coding[i] == "A") &
       (DNA_Real_Coding[i+1] == "T") &
       (DNA_Real_Coding[i+2] == "G"))
    {
      Bool = TRUE
    }
    
    if(Bool == TRUE)
    {
      Amino_acid_real[i] = 
        Check_Amino(DNA_Real_Coding[i:(i+2)])
    }
    
    if((DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "A" &
        DNA_Real_Coding[i+2] == "A") |
       (DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "A" &
        DNA_Real_Coding[i+2] == "G") |
       (DNA_Real_Coding[i] == "T" &
        DNA_Real_Coding[i+1] == "G" &
        DNA_Real_Coding[i+2] == "A"))
    {
      Bool = FALSE
    }
    
    j = j+1
  }
  
  return(Amino_acid_real)
}

Proteins_Real = Protein(DNA_Real_Code)
Proteins_Predicted = Protein(DNA_Predicted_Code)

l_1 = length(Proteins_Real)/3

Proteins_1_R = numeric(l_1)
Proteins_2_R = numeric(l_1)
Proteins_3_R = numeric(l_1)

for(i in 1:l_1)
{
  Proteins_1_R[i] = Proteins_Real[3*(i-1)+1]
  Proteins_2_R[i] = Proteins_Real[3*(i-1)+2]
  Proteins_3_R[i] = Proteins_Real[3*(i)]
}

l_2 = length(Proteins_Predicted)/3

Proteins_1_P = numeric(l_2)
Proteins_2_P = numeric(l_2)
Proteins_3_P = numeric(l_2)

for(i in 1:l_2)
{
  Proteins_1_P[i] = Proteins_Predicted[3*(i-1)+1]
  Proteins_2_P[i] = Proteins_Predicted[3*(i-1)+2]
  Proteins_3_P[i] = Proteins_Predicted[3*(i)]
}

sum(Proteins_1_R == Proteins_1_P)/1179
sum(Proteins_2_R == Proteins_2_P)/1179
sum(Proteins_3_R == Proteins_3_P)/1179



DNA_Predict_Code = DNA_Sequence[num+which(Gen_Seq$states == "C")]
DNA_Reality_Code = DNA_Sequence[num+which(Coding_Sequence[(num+1):length(DNA_Sequence)] == "C")]

DNA_Predict_Code_1 = c(rep(0,13),DNA_Predict_Code)
DNA_Reality_Code_1 = c(DNA_Reality_Code,rep(0,434))

Proteins_Reality = Protein(DNA_Reality_Code_1)
Proteins_Predict = Protein(DNA_Predict_Code_1)

l_11 = (length(Proteins_Reality)-2)/3

Proteins_11_R = numeric(l_11)
Proteins_12_R = numeric(l_11)
Proteins_13_R = numeric(l_11)

for(i in 1:l_1)
{
  Proteins_11_R[i] = Proteins_Reality[3*(i-1)+1]
  Proteins_12_R[i] = Proteins_Reality[3*(i-1)+2]
  Proteins_13_R[i] = Proteins_Reality[3*(i)]
}

l_12 = (length(Proteins_Predict)-2)/3

Proteins_11_P = numeric(l_12)
Proteins_12_P = numeric(l_12)
Proteins_13_P = numeric(l_12)

for(i in 1:l_12)
{
  Proteins_11_P[i] = Proteins_Predict[3*(i-1)+1]
  Proteins_12_P[i] = Proteins_Predict[3*(i-1)+2]
  Proteins_13_P[i] = Proteins_Predict[3*(i)]
}


sum(DNA_Reality_Code_1 == DNA_Predict_Code_1)/3912

sum(Proteins_11_R == Proteins_11_P)/1303
sum(Proteins_12_R == Proteins_12_P)/1303
sum(Proteins_13_R == Proteins_13_P)/1303

real_hist = numeric(length(DNA_Reality_Code))
for(i in 1:length(DNA_Reality_Code))
{
  if(DNA_Reality_Code[i] == "A")
  {
    real_hist[i] = 1
  }else if(DNA_Reality_Code[i] == "C")
  {
    real_hist[i] = 2
  }else if(DNA_Reality_Code[i] == "G")
  {
    real_hist[i] = 3
  }else if(DNA_Reality_Code[i] == "T")
  {
    real_hist[i] = 4
  }
}

hist(real_hist, freq = TRUE, breaks = c(0,1,2,3,4),
     xaxt = 'n', col = c("blue", "red", "yellow", "green"),
     xlab = "Nucleotides", main = "Real")
axis(1, at=c(0.5,1.5,2.5,3.5), labels=c("A","C","G","T"))

pred_hist = numeric(length(DNA_Reality_Code))
for(i in 1:length(DNA_Reality_Code))
{
  if(DNA_Predict_Code[i] == "A")
  {
    pred_hist[i] = 1
  }else if(DNA_Predict_Code[i] == "C")
  {
    pred_hist[i] = 2
  }else if(DNA_Predict_Code[i] == "G")
  {
    pred_hist[i] = 3
  }else if(DNA_Predict_Code[i] == "T")
  {
    pred_hist[i] = 4
  }
}

hist(pred_hist, freq = TRUE, breaks = c(0,1,2,3,4),
     xaxt = 'n', col = c("blue", "red", "yellow", "green"),
     xlab = "Nucleotides", main = "Predicted")
axis(1, at=c(0.5,1.5,2.5,3.5), labels=c("A","C","G","T"))

full_hist = numeric(length(DNA_Reality_Code))
for(i in 1:length(DNA_Reality_Code))
{
  if(DNA_Predict_Code[i] == "A")
  {
    full_hist[i] = 0.5
  }else if(DNA_Predict_Code[i] == "C")
  {
    full_hist[i] = 1.5
  }else if(DNA_Predict_Code[i] == "G")
  {
    full_hist[i] = 2.5
  }else if(DNA_Predict_Code[i] == "T")
  {
    full_hist[i] = 3.5
  }
}
all_hist = c(full_hist, real_hist)

hist(all_hist, freq = TRUE, breaks = c(0,0.5,1,1.5,2,2.5,3,3.5,4),
     col = c("blue", "blue", "red", "red", "yellow", "yellow", "green", "green"),
     xaxt = 'n', xlab = "Nucleotides", main = "Real vs Predicted")
axis(1, at=c(0.5,1.5,2.5,3.5), labels=c("A","C","G","T"))












